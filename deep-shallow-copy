# ğŸ§  Deep Copy vs Shallow Copy in Python

When you copy objects in Python, itâ€™s important to understand what gets copied, just the references to objects or the entire object and its contents. This distinction is between shallow copy and deep copy.

---

## ğŸ“‹ Shallow Copy

A shallow copy creates a new object, but does not create copies of nested objects. Instead, it copies references to the nested objects.
Ë€
**âœ… Characteristics:

* Outer container is copied.
* Inner objects (e.g., lists, dicts) are shared (point to the same memory).

**ğŸ“Œ Example:**Ë€

import copy
original = \[\[1, 2], \[3, 4]]
shallow = copy.copy(original)

shallow\[0]\[0] = 999

print("Original:", original)
print("Shallow:", shallow)

**ğŸ” Output:**
Original: \[\[999, 2], \[3, 4]]
Shallow:  \[\[999, 2], \[3, 4]]

ğŸ§  Even though we modified shallow, original also changed because they share inner lists.

---

## ğŸ§¬ Deep Copy

A deep copy creates a new object, and recursively copies all nested objects. This results in a completely independent clone.

**âœ… Characteristics:**

* Entire structure is duplicated.
* Changes in the copied object do not affect the original.

**ğŸ“Œ Example:**

import copy
original = \[\[1, 2], \[3, 4]]
deep = copy.deepcopy(original)

deep\[0]\[0] = 999

print("Original:", original)
print("Deep:", deep)

**ğŸ” Output:**
Original: \[\[1, 2], \[3, 4]]
Deep:     \[\[999, 2], \[3, 4]]

ğŸ§  The original remains unaffected, because the nested lists were also copied independently.

---

## ğŸ”¬ Internal Memory Structure

copy.copy() â€“ copies one level (outer object), references inside.
copy.deepcopy() â€“ creates new memory for everything, recursively.

---

## âš–ï¸ Shallow vs Deep Copy â€“ Comparison

**Shallow Copy (copy.copy):**

* Copies outer object: Yes
* Copies inner objects: No
* Independent from original: No (inner items shared)
* Performance: Fast
* Use case: Immutable nested values

**Deep Copy (copy.deepcopy):**

* Copies outer object: Yes
* Copies inner objects: Yes
* Independent from original: Yes
* Performance: Slower (recursive)
* Use case: Complex or mutable structures

---

## ğŸ“› Common Pitfalls

a = \[\[1, 2]]
b = a.copy()       # shallow copy
b\[0]\[0] = 99       # also changes a

c = copy.deepcopy(a)
c\[0]\[0] = 88       # a is untouched

ğŸ›‘ Avoid shallow copy if inner objects are mutable and will be modified.

---

## ğŸ”§ Custom Objects & Deep Copy

For classes with nested objects, deepcopy() uses **deepcopy**() internally (if defined).

class Person:
  def **init**(self, name, friends):
    self.name = name
    self.friends = friends

import copy
p1 = Person("Alice", \["Bob", "Eve"])
p2 = copy.deepcopy(p1)
p2.friends\[0] = "Charlie"

print(p1.friends)  # \['Bob', 'Eve']

---

## ğŸ“¦ Summary

**Shallow Copy**
Independent Inner Objects? No
Use When... Inner data wonâ€™t be changed

**Deep Copy**
Independent Inner Objects? Yes
Use When... Nested structures or mutation needed

---